<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `resolv` mod in crate `domain`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, resolv">

    <title>domain::resolv - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../normalize.css">
    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>domain</a></p><script>window.sidebarCurrent = {name: 'resolv', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Module <a href='../index.html'>domain</a>::<wbr><a class="mod" href=''>resolv</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../../src/domain/resolv/mod.rs.html#1-238' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>An asynchronous stub resolver.</p>

<p>A resolver is the component in the DNS that answers queries. A stub
resolver does so by simply relaying queries to a different resolver
chosen from a predefined set. This is how pretty much all user
applications use DNS.</p>

<p>This module implements a modern, asynchronous stub resolver built on
top of <a href="https://github.com/alexcrichton/futures-rs">futures</a> and <a href="https://tokio.rs/">tokio</a>.</p>

<p>The module provides ways to create a <em>resolver</em> that knows how to
process DNS <em>queries</em>. A query asks for all the resource records
associated with a given triple of a domain name, resource record type,
and class (known as a <em>question</em>). It is a future resolving to a DNS
message with a successful response or an error. Queries can be combined
into <em>lookups</em> that use the returned resource records to answer more
specific enquiries such as all the IP addresses associated with a given
host name. The module provides a rich set of common lookups in the
<a href="lookup/index.html">lookup</a> sub-module.</p>

<p>The following gives an introduction into using the resolver. For an
introduction into the internal design, please have a look at the <a href="intro/index.html">intro</a>
sub-module.</p>

<h1 id='creating-a-resolver' class='section-header'><a href='#creating-a-resolver'>Creating a Resolver</a></h1>
<p>The resolver is represented by the <a href="struct.Resolver.html"><code>Resolver</code></a> type. When creating a
value of this type, you create all the parts of an actual resolver
according to a resolver configuration. Since these parts are handling
actual network traffic, the resolver needs a handle to a Tokio reactor
into which these parts will be spawned as futures.</p>

<p>For the resolver configuration, there’s <a href="conf/struct.ResolvConf.html"><code>ResolvConf</code></a>. While you can
create a value of this type by hand, the more common way is to use your
system’s resolver configuration. <a href="conf/struct.ResolvConf.html"><code>ResolvConf</code></a> implements the <code>Default</code>
trait doing exactly that by reading <code>/etc/resolv.conf</code>.</p>

<blockquote>
<p>That probably won’t work on Windows, but, sadly, I have no idea how to
retrieve the resolver configuration there. Some help here would be
very much appreciated.</p>
</blockquote>

<p>Since using the system configuration is the most common case by far,
<a href="struct.Resolver.html"><code>Resolver</code></a>’s <code>new()</code> function does just that. So, the easiest way to
get a resolver is just this:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">resolv</span>::<span class="ident">Resolver</span>;
<span class="kw">use</span> <span class="ident">tokio_core</span>::<span class="ident">reactor</span>::<span class="ident">Core</span>;

<span class="kw">let</span> <span class="ident">core</span> <span class="op">=</span> <span class="ident">Core</span>::<span class="ident">new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">resolv</span> <span class="op">=</span> <span class="ident">Resolver</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">core</span>.<span class="ident">handle</span>());</pre>

<p>If you do have a configuration, you can use the <code>from_conf()</code> function
instead.</p>

<h1 id='using-the-resolver-queries' class='section-header'><a href='#using-the-resolver-queries'>Using the Resolver: Queries</a></h1>
<p>As was mentioned above, the <a href="struct.Resolver.html"><code>Resolver</code></a> doesn’t actually contain the
networking parts necessary to answer queries. Instead, it only knows how
to contact those parts. Because of this, you can clone the resolver,
even pass it to other threads.</p>

<p>The main purpose of the resover, though, is to start queries. This is
done through <a href="struct.Resolver.html#method.query"><code>Resolver::query()</code></a>. It takes something that can be
turned into a question and returns a future that will resolve into
either a <a href="../bits/message/struct.MessageBuf.html"><code>MessageBuf</code></a> with the response to the query or an <a href="error/enum.Error.html"><code>Error</code></a>. 
Luckily, a triple of a domain name, a resource record type, and a class
is something than can be turned into a question, so you don’t need to
build the question from hand. (You will have to convert a string into
a domain name from hand since that may fail.)</p>

<p>As an example, let’s find out the IPv6 addresses for <code>www.rust-lang.org</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">domain</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">futures</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">tokio_core</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>::<span class="ident">FromStr</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">bits</span>::<span class="ident">DNameBuf</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">iana</span>::{<span class="ident">Class</span>, <span class="ident">Rtype</span>};
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">rdata</span>::<span class="ident">Aaaa</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">resolv</span>::<span class="ident">Resolver</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">Future</span>;
<span class="kw">use</span> <span class="ident">tokio_core</span>::<span class="ident">reactor</span>::<span class="ident">Core</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">core</span> <span class="op">=</span> <span class="ident">Core</span>::<span class="ident">new</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">resolv</span> <span class="op">=</span> <span class="ident">Resolver</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">core</span>.<span class="ident">handle</span>());

    <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">DNameBuf</span>::<span class="ident">from_str</span>(<span class="string">&quot;www.rust-lang.org.&quot;</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">addrs</span> <span class="op">=</span> <span class="ident">resolv</span>.<span class="ident">query</span>((<span class="ident">name</span>, <span class="ident">Rtype</span>::<span class="ident">Aaaa</span>, <span class="ident">Class</span>::<span class="ident">In</span>));
    <span class="kw">let</span> <span class="ident">response</span> <span class="op">=</span> <span class="ident">core</span>.<span class="ident">run</span>(<span class="ident">addrs</span>).<span class="ident">unwrap</span>();
    <span class="kw">for</span> <span class="ident">record</span> <span class="kw">in</span> <span class="ident">response</span>.<span class="ident">answer</span>().<span class="ident">unwrap</span>().<span class="ident">limit_to</span>::<span class="op">&lt;</span><span class="ident">Aaaa</span><span class="op">&gt;</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">record</span>.<span class="ident">unwrap</span>());
    }
}</pre>

<p>Note the final dot at <code>&quot;www.rust-lang.org.&quot;</code> making it an absolute domain
name. Queries don’t know how to deal with relative names and will error
out if given one.</p>

<h1 id='complex-queries-lookups' class='section-header'><a href='#complex-queries-lookups'>Complex Queries: Lookups</a></h1>
<p>Most times when you are using DNS you aren’t really interested in a
bunch of resource records. You want an answer to a more direct
question. For instance, if you want to know the IP addresses for a
host name, you don’t really care that you have to make a query for the
<code>A</code> records and one for <code>AAAA</code> records for that host name. You want the
addresses.</p>

<p>This is what lookups do. They are functions that take a <a href="struct.Resolver.html"><code>Resolver</code></a>
and some additional information and turn that into a future of some
specific result.</p>

<p>Using <a href="lookup/fn.lookup_host.html"><code>lookup_host()</code></a>, the process of looking up the IP addresses
becomes much easier. To update above’s example:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">domain</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">futures</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">tokio_core</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>::<span class="ident">FromStr</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">bits</span>::<span class="ident">DNameBuf</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">resolv</span>::<span class="ident">Resolver</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">resolv</span>::<span class="ident">lookup</span>::<span class="ident">lookup_host</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">Future</span>;
<span class="kw">use</span> <span class="ident">tokio_core</span>::<span class="ident">reactor</span>::<span class="ident">Core</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">core</span> <span class="op">=</span> <span class="ident">Core</span>::<span class="ident">new</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">resolv</span> <span class="op">=</span> <span class="ident">Resolver</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">core</span>.<span class="ident">handle</span>());

    <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">DNameBuf</span>::<span class="ident">from_str</span>(<span class="string">&quot;www.rust-lang.org&quot;</span>).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">addrs</span> <span class="op">=</span> <span class="ident">lookup_host</span>(<span class="ident">resolv</span>, <span class="ident">name</span>);
    <span class="kw">let</span> <span class="ident">response</span> <span class="op">=</span> <span class="ident">core</span>.<span class="ident">run</span>(<span class="ident">addrs</span>).<span class="ident">unwrap</span>();
    <span class="kw">for</span> <span class="ident">addr</span> <span class="kw">in</span> <span class="ident">response</span>.<span class="ident">iter</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">addr</span>);
    }
}</pre>

<p>No more fiddeling with record types and classes and the result can now
iterate over IP addresses. And we get both IPv4 and IPv6 addresses to
boot.</p>

<p>Furthermore, we now can use a relative host name. It will be turned into
an absolute name according to the rules set down by the configuration we
used when creating the resolver.</p>

<p>As an aside, the lookup functions are named after the thing they look
up not their result following the example of the standard library. So,
when you look for the addresses for the host, you have to use
<a href="lookup/fn.lookup_host.html"><code>lookup_host()</code></a>, not <a href="lookup/fn.lookup_addr.html"><code>lookup_addr()</code></a>.</p>

<p>Have a look at the <a href="lookup/index.html">lookup</a> module for all the lookup functions
currently available.</p>

<h1 id='the-run-shortcut' class='section-header'><a href='#the-run-shortcut'>The Run Shortcut</a></h1>
<p>If you only want to do a DNS lookup and don’t otherwise use tokio, there
is a shortcut through the <a href="struct.Resolver.html#method.run"><code>Resolver::run()</code></a> associated function. It
takes a closure from a <a href="struct.Resolver.html"><code>Resolver</code></a> to a future and waits while
driving the future to completing. In other words, it takes away all the
boiler plate from above:</p>

<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">domain</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>::<span class="ident">FromStr</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">bits</span>::<span class="ident">DNameBuf</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">resolv</span>::<span class="ident">Resolver</span>;
<span class="kw">use</span> <span class="ident">domain</span>::<span class="ident">resolv</span>::<span class="ident">lookup</span>::<span class="ident">lookup_host</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">response</span> <span class="op">=</span> <span class="ident">Resolver</span>::<span class="ident">run</span>(<span class="op">|</span><span class="ident">resolv</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">DNameBuf</span>::<span class="ident">from_str</span>(<span class="string">&quot;www.rust-lang.org&quot;</span>).<span class="ident">unwrap</span>();
        <span class="ident">lookup_host</span>(<span class="ident">resolv</span>, <span class="ident">name</span>)
    });
    <span class="kw">for</span> <span class="ident">addr</span> <span class="kw">in</span> <span class="ident">response</span>.<span class="ident">unwrap</span>().<span class="ident">iter</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">addr</span>);
    }
}</pre>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use self::<a class="mod"
                                           href="./conf/index.html">conf</a>::<a class="struct" href="../../domain/resolv/conf/struct.ResolvConf.html" title="struct domain::resolv::conf::ResolvConf">ResolvConf</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="mod" href="conf/index.html"
                                  title='mod domain::resolv::conf'>conf</a></td>
                           <td class='docblock-short'>
                                <p>Resolver configuration</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="error/index.html"
                                  title='mod domain::resolv::error'>error</a></td>
                           <td class='docblock-short'>
                                <p>Resolver errors and results.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="intro/index.html"
                                  title='mod domain::resolv::intro'>intro</a></td>
                           <td class='docblock-short'>
                                <p>Resolver Architecture Documentation</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="lookup/index.html"
                                  title='mod domain::resolv::lookup'>lookup</a></td>
                           <td class='docblock-short'>
                                <p>Lookup functions and related types.</p>
                           </td>
                       </tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Query.html"
                                  title='struct domain::resolv::Query'>Query</a></td>
                           <td class='docblock-short'>
                                <p>A DNS query.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Resolver.html"
                                  title='struct domain::resolv::Resolver'>Resolver</a></td>
                           <td class='docblock-short'>
                                <p>Access to a DNS resolver.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "domain";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>